<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Training Dashboard — Vollständig (Option B)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#0f1720; --panel:#071024; --console-bg:#02111a;
      --info:#60a5fa; --warn:#f59e0b; --err:#ef4444; --ok:#10b981; --muted:#94a3b8;
      --accent:'#9ad3ff';
    }
    html,body{height:100%; margin:0; font-family:Inter, Roboto, "Segoe UI", Arial; background:linear-gradient(180deg,#071025 0%, #061827 100%); color:#e6eef6;}
    .topbar{padding:14px 18px; display:flex; gap:12px; align-items:center;}
    .title{font-weight:700; font-size:18px; color:var(--accent); margin-right:8px;}
    .container{display:grid; grid-template-columns: 1fr 560px; gap:16px; padding:0 18px 18px 18px; align-items:start;}
    .console-panel, .charts-panel{background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 6px 16px rgba(0,0,0,0.6);}
    .console-panel{display:flex; flex-direction:column; min-height: calc(100vh - 120px);}
    .controls{display:flex; gap:8px; align-items:center; margin-bottom:8px;}
    .btn{background:#0b1220;border:1px solid #10202a;padding:8px 10px;color:var(--muted);border-radius:8px;cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,#2ea0ff,#0dd3b0); color:#02111a; border:none; font-weight:600}
    .dropzone{flex:0 0 auto; border:2px dashed rgba(255,255,255,0.04); border-radius:10px; padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); color:var(--muted)}
    #fileInput{display:none}
    .console{background:var(--console-bg); border-radius:8px; padding:12px; flex:1 1 auto; overflow:auto; font-family:Consolas, "Courier New", monospace; font-size:12px; color:#dbeefd; white-space:pre-wrap;}
    .chart-wrapper{display:flex; flex-direction:column; gap:10px; max-height: calc(100vh - 160px); overflow:auto;}
    .tabs{display:flex; gap:6px; flex-wrap:wrap; margin-bottom:8px;}
    .tab{padding:8px 10px; background:#06101a; border-radius:8px; border:1px solid rgba(255,255,255,0.02); cursor:pointer; color:var(--muted)}
    .tab.active{background:linear-gradient(90deg,#072034,#0b2c3f); color:#dff7ff; border-color:rgba(255,255,255,0.06)}
    .chart-card{background:linear-gradient(180deg,#071827,#021016); border-radius:8px; padding:10px; border:1px solid rgba(255,255,255,0.03)}
    .chart-title{display:flex; align-items:center; gap:10px; margin-bottom:8px}
    .chart-area{width:100%; height:380px}
    .info-pop{background:#06222d;color:#dff7ff;padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.03)}
    .metric-meta{font-size:13px;color:var(--muted)}
    .legend{display:flex; gap:8px; flex-wrap:wrap}
    .legend .item{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px}
    .color-swatch{width:12px;height:12px;border-radius:3px}
    .small{font-size:13px;color:var(--muted)}
    .export-btn{margin-left:auto}
    @media (max-width:1180px){ .container{grid-template-columns:1fr; } .chart-area{height:320px} .console{min-height:240px} }
    /* progress line styling inside console */
    .progress-line{display:flex; gap:10px; align-items:center; padding:4px 0}
    .progress-bar{height:10px; width:420px; background:#0b1620; border-radius:6px; overflow:hidden}
    .progress-inner{height:100%; display:block}
    .chip{display:inline-block;padding:4px 8px;border-radius:10px;background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px}
    .popover{background:#071827;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:#dff7ff}
  </style>
</head>
<body>
  <div class="topbar">
    <div class="title">Training Dashboard — Option B (vollständig)</div>
    <div class="small">Automatische Metrikerkennung • Drag & Drop • Export • Info-Popovers</div>
  </div>

  <div class="container">
    <!-- Console / Left -->
    <div class="console-panel">
      <div style="display:flex; gap:8px; align-items:center;">
        <div class="controls">
          <label class="btn" for="fileInput">Datei öffnen</label>
          <input id="fileInput" type="file" accept=".txt,.log,.out,.json,.log.txt" />
          <button class="btn primary" id="parseBtn">Parsen & Charts aktualisieren</button>
          <button class="btn" id="clearBtn">Konsole leeren</button>
        </div>
        <div style="margin-left:auto" class="small">Ziehe deine Log-Datei in die Konsole (Drag & Drop)</div>
      </div>

      <div class="dropzone" id="dropzone" style="margin-top:8px;">
        Datei per Drag & Drop hier ablegen oder auf "Datei öffnen" klicken
      </div>

      <div id="console" class="console" contenteditable="false" aria-live="polite" style="margin-top:10px;">
      <!-- Konsole (wird vom Script gefüllt) -->
      Paste / drop your training log here — dann auf "Parsen & Charts aktualisieren" klicken.
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <div class="chip">Detected metrics: <span id="detectedCount">0</span></div>
        <div class="chip">Epochs: <span id="epochCount">0</span></div>
        <div class="small" style="margin-left:auto">Export: Charts → PNG / JSON</div>
      </div>
    </div>

    <!-- Charts / Right -->
    <div class="charts-panel">
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <div class="tabs" id="tabs"></div>
        <div class="small" style="margin-left:auto">Tipp: Klicke Tab-Namen für Metrik-Infos</div>
      </div>

      <div class="chart-wrapper" id="chartsContainer">
        <!-- Chart cards werden per JS erzeugt -->
      </div>

      <div style="margin-top:10px;">
        <div class="chart-card">
          <div style="display:flex; align-items:flex-start; gap:12px;">
            <div style="flex:1">
              <div style="font-weight:700">Legende & Erläuterungen</div>
              <div class="small" style="margin-top:6px">
                Jede Metrik wird automatisch erkannt und als Chart angeboten. Klicke auf das Info-Icon in einem Tab, um die Beschreibung und Handlungshinweise zur jeweiligen Metrik zu sehen.
              </div>
            </div>
            <div style="width:240px">
              <div style="font-weight:600; margin-bottom:6px">Farben (Kategorie)</div>
              <div class="legend">
                <div class="item"><div class="color-swatch" style="background:var(--ok)"></div><div class="small">Performance</div></div>
                <div class="item"><div class="color-swatch" style="background:var(--info)"></div><div class="small">Throughput / IO</div></div>
                <div class="item"><div class="color-swatch" style="background:var(--warn)"></div><div class="small">Warnung / Scheduler</div></div>
                <div class="item"><div class="color-swatch" style="background:var(--err)"></div><div class="small">Fehler / starke Abweichung</div></div>
              </div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/* ========= Dashboard Script (Option B) =========
 - automatische Metrik-Erkennung
 - Drag & Drop + File-Input
 - Chart-Factory für alle Metriken (Chart.js)
 - Info-Popover / Beschreibungen pro Metrik
 - Export PNG / Download JSON
=============================================== */

/* Metric metadata (Beschreibung / Handlungsempfehlung) */
const METRIC_INFO = {
  epoch: { name:'epoch', desc:'Epoch-Nummer (vollständige Durchläufe über den Dataset)', tip:'Verwendet zur Aggregation; keine direkte Performance-Metrik.' },
  train_loss: { name:'train_loss', desc:'Trainingsverlust', tip:'Soll im Training sinken; persistierender hoher Wert -> Modell passt nicht gut.' },
  eval_loss: { name:'eval_loss', desc:'Validierungs-/Evaluation-Loss', tip:'Sinkt mit guter Generalisierung; Abweichung zu train_loss deutet auf Over/Underfitting.' },
  eval_accuracy: { name:'eval_accuracy', desc:'Eval Accuracy', tip:'Anteil korrekter Vorhersagen; kombiniere mit F1 für ausgeglichene Betrachtung.' },
  eval_f1: { name:'eval_f1', desc:'F1-Score', tip:'Harmonisches Mittel von Precision und Recall; besser bei Klassenimbalancen.' },
  eval_precision: { name:'eval_precision', desc:'Precision (Eval)', tip:'Hohe Precision = wenige False Positives.' },
  eval_recall: { name:'eval_recall', desc:'Recall (Eval)', tip:'Hohe Recall = wenige False Negatives.' },
  grad_norm: { name:'grad_norm', desc:'Gradient Norm', tip:'Hohe Spitzen können auf instabile Trainingsschritte hinweisen; ggf. Gradient Clipping überlegen.' },
  learning_rate: { name:'learning_rate', desc:'Lernrate (Scheduler-Wert)', tip:'Zeigt Scheduling; plötzliche Änderungen können Trainingsdynamik beeinflussen.' },
  train_samples_per_second: { name:'train_samples_per_second', desc:'Train Samples/s', tip:'Durchsatz beim Training; Engelpunkt für I/O/Batchsize/Hardware.' },
  train_steps_per_second: { name:'train_steps_per_second', desc:'Train Steps/s', tip:'Schritte pro Sekunde beim Training; sinkt bei Bottlenecks.' },
  eval_samples_per_second: { name:'eval_samples_per_second', desc:'Eval Samples/s', tip:'Durchsatz bei Evaluierung.' },
  eval_steps_per_second: { name:'eval_steps_per_second', desc:'Eval Steps/s', tip:'Evaluations-Schritte pro Sekunde.' },
  train_runtime: { name:'train_runtime', desc:'Train Runtime', tip:'Gesamtzeit des Trainingsdurchlaufs.' },
  learning_rate_schedule_event: { name:'learning_rate_schedule_event', desc:'LR Scheduler Event', tip:'Markiert spezielle Scheduler-Events.' }
};

/* colors per category */
const COLOR_MAP = {
  loss:'#ff6b6b', // loss-ish
  perf:'#10b981', // accuracy/f1
  throughput:'#60a5fa', // samples/s
  scheduler:'#f59e0b',
  grad:'#d946ef',
  default:'#9ad3ff'
};

const consoleEl = document.getElementById('console');
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const parseBtn = document.getElementById('parseBtn');
const clearBtn = document.getElementById('clearBtn');
const detectedCountEl = document.getElementById('detectedCount');
const epochCountEl = document.getElementById('epochCount');
const tabsEl = document.getElementById('tabs');
const chartsContainer = document.getElementById('chartsContainer');

let metricsByEpoch = []; // array of metric objects (one per epoch if available)
let allMetricKeys = [];  // discovered metric keys
let chartInstances = {}; // Chart.js instances keyed by metric
let chartCanvases = {};  // mapping metric -> canvas element id

/* ---------- Drag & Drop & File Input ---------- */
dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.style.borderColor = '#2ea0ff'; });
dropzone.addEventListener('dragleave', e=>{ dropzone.style.borderColor = 'rgba(255,255,255,0.04)'; });
dropzone.addEventListener('drop', e=>{
  e.preventDefault(); dropzone.style.borderColor = 'rgba(255,255,255,0.04)';
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(f) readFile(f);
});
fileInput.addEventListener('change', ()=>{ const f = fileInput.files && fileInput.files[0]; if(f) readFile(f); fileInput.value=''; });
clearBtn.addEventListener('click', ()=>{ consoleEl.textContent=''; metricsByEpoch=[]; allMetricKeys=[]; updateUI(); });

function readFile(file){
  const reader = new FileReader();
  reader.onload = ev => {
    consoleEl.textContent = ev.target.result;
    // auto-parse to update UI if you prefer
  };
  reader.onerror = ()=> alert('Fehler beim Lesen der Datei');
  reader.readAsText(file, 'utf-8');
}

/* ---------- Parsing: erkenne JSON-like metric objects ---------- */
function parseMetricsFromText(raw){
  const metrics = [];
  if(!raw || raw.trim().length===0) return metrics;

  // 1) Suche Python-dict- oder JSON-ähnliche Objekte, die 'epoch' enthalten
  // regex: find {... 'epoch': number ...}
  const objRegex = /\{[^}]*'epoch'\s*:\s*[\d.]+[^}]*\}|\{[^}]*"epoch"\s*:\s*[\d.]+[^}]*\}/g;
  const found = raw.match(objRegex) || [];

  for(const block of found){
    // normalize quotes: 'key': -> "key":
    let j = block.replace(/([a-zA-Z0-9_]+)\s*:/g, '"$1":'); // keys
    j = j.replace(/'([^']*)'/g, '"$1"'); // single quotes to double
    j = j.replace(/,(\s*})/g,'$1'); // strip trailing commas
    try{
      const obj = JSON.parse(j);
      metrics.push(obj);
    }catch(e){
      // ignore single parse failure
    }
  }

  // 2) If none found, try to detect inline "key: value" patterns per line and aggregate by epoch
  if(metrics.length===0){
    // split into lines, look for lines containing keys we care about
    const lines = raw.split(/\r?\n/);
    let current = {};
    for(const ln of lines){
      // try match patterns like "'eval_loss': 0.778" or "eval_loss: 0.778"
      const kvRegex = /['"]?([a-zA-Z0-9_]+)['"]?\s*[:=]\s*([-+]?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?)/g;
      let m; let changed=false;
      while((m = kvRegex.exec(ln)) !== null){
        const k = m[1]; const v = parseFloat(m[2]);
        current[k] = v; changed=true;
      }
      if(changed && current.epoch!==undefined){
        // push copy
        metrics.push(Object.assign({}, current));
        current = {};
      }
    }
  }

  // 3) dedupe/sort by epoch if epoch exists
  metrics.sort((a,b)=> (a.epoch||0) - (b.epoch||0));
  return metrics;
}

/* ---------- Chart factory & helpers ---------- */
function detectAllMetricKeys(metrics){
  const keys = new Set();
  for(const m of metrics){
    Object.keys(m).forEach(k=> keys.add(k));
  }
  // ensure epoch first
  const arr = Array.from(keys);
  arr.sort((a,b)=>{
    if(a==='epoch') return -1;
    if(b==='epoch') return 1;
    return a.localeCompare(b);
  });
  return arr;
}

function colorForKey(key){
  if(key.includes('loss')) return COLOR_MAP.loss;
  if(key.includes('accuracy') || key.includes('f1') || key.includes('precision') || key.includes('recall')) return COLOR_MAP.perf;
  if(key.includes('samples') || key.includes('steps')) return COLOR_MAP.throughput;
  if(key.includes('learning_rate')) return COLOR_MAP.scheduler;
  if(key.includes('grad')) return COLOR_MAP.grad;
  return COLOR_MAP.default;
}

function makeChartCard(metricKey){
  const card = document.createElement('div');
  card.className = 'chart-card';
  const titleRow = document.createElement('div'); titleRow.className='chart-title';
  const left = document.createElement('div');
  left.innerHTML = `<div style="font-weight:700">${metricKey}</div>
    <div class="metric-meta">${METRIC_INFO[metricKey]?.desc || 'Zeitreihe der Metrik'}</div>`;
  const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';

  // Info button
  const infoBtn = document.createElement('button'); infoBtn.className='btn'; infoBtn.textContent='Info';
  infoBtn.onclick = ()=> showMetricInfo(metricKey);
  right.appendChild(infoBtn);

  // export button
  const expBtn = document.createElement('button'); expBtn.className='btn'; expBtn.textContent='Export PNG';
  expBtn.onclick = ()=> exportChartPNG(metricKey);
  right.appendChild(expBtn);

  // export json
  const jsonBtn = document.createElement('button'); jsonBtn.className='btn'; jsonBtn.textContent='Export JSON';
  jsonBtn.onclick = ()=> exportChartJSON(metricKey);
  right.appendChild(jsonBtn);

  titleRow.appendChild(left); titleRow.appendChild(right);
  card.appendChild(titleRow);

  // canvas container
  const canvasId = 'chart_'+metricKey.replace(/[^a-zA-Z0-9]/g,'_');
  chartCanvases[metricKey] = canvasId;
  const canvasWrap = document.createElement('div');
  canvasWrap.className='chart-area';
  canvasWrap.style.background='linear-gradient(180deg, rgba(255,255,255,0.01), transparent)';
  const canvas = document.createElement('canvas');
  canvas.id = canvasId; canvas.style.width='100%'; canvas.style.height='100%';
  canvasWrap.appendChild(canvas);
  card.appendChild(canvasWrap);

  // add descriptive paragraph under chart
  const desc = document.createElement('div');
  desc.className='small';
  desc.style.marginTop='8px';
  desc.innerHTML = METRIC_INFO[metricKey]?.tip ? METRIC_INFO[metricKey].tip : 'Kurze Beschreibung und Tipps zur Interpretation.';
  card.appendChild(desc);

  return card;
}

function buildCharts(metrics){
  // remove previous
  chartsContainer.innerHTML=''; chartInstances={};

  if(!metrics || metrics.length===0) return;

  allMetricKeys = detectAllMetricKeys(metrics);
  detectedCountEl.textContent = allMetricKeys.length;

  // render a tab for each metric (primary list)
  tabsEl.innerHTML='';
  allMetricKeys.forEach((k,i)=>{
    const t = document.createElement('div'); t.className='tab' + (i===0? ' active':''); t.textContent = k;
    t.dataset.key = k;
    t.onclick = ()=> {
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      // scroll to chart
      const el = document.getElementById(chartCanvases[k]).closest('.chart-card');
      if(el) el.scrollIntoView({behavior:'smooth', block:'center'});
    };
    tabsEl.appendChild(t);
  });

  // For each metric, create a chart card and create Chart.js
  for(const key of allMetricKeys){
    const card = makeChartCard(key);
    chartsContainer.appendChild(card);

    // prepare series: X = epoch if present otherwise step index
    const hasEpoch = metrics.some(m=> m.epoch!==undefined);
    const x = []; const y = [];
    for(const m of metrics){
      const xv = hasEpoch ? (m.epoch!==undefined ? m.epoch : null) : (m.step!==undefined ? m.step : null);
      // if no x available, push index
      x.push(xv !== null ? xv : metrics.indexOf(m)+1);
      y.push(m[key] !== undefined ? m[key] : null);
    }

    // Chart.js config
    const ctx = document.getElementById(chartCanvases[key]).getContext('2d');
    const datasetColor = colorForKey(key);
    const cfg = {
      type:'line',
      data: {
        labels: x,
        datasets: [{
          label: key,
          data: y,
          borderColor: datasetColor,
          backgroundColor: hexToRgba(datasetColor, 0.12),
          tension: 0.18,
          spanGaps: true,
          pointRadius: 3
        }]
      },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          title:{display:true, text: key},
          tooltip:{mode:'index', intersect:false},
          legend:{display:false}
        },
        scales:{
          x:{ title: {display:true, text: hasEpoch ? 'epoch' : 'step'}, ticks:{color:'#bfe9ff'} },
          y:{ title: {display:true, text: key}, ticks:{color:'#bfe9ff'} }
        }
      }
    };

    // destroy existing if any
    if(chartInstances[key]){ try{ chartInstances[key].destroy(); }catch{} }
    chartInstances[key] = new Chart(ctx, cfg);
  }

  // epoch count
  const epochSet = new Set(metrics.filter(m=>m.epoch!==undefined).map(m=>m.epoch));
  epochCountEl.textContent = epochSet.size || 0;
}

/* ---------- Utility: hex to rgba ---------- */
function hexToRgba(hex,alpha){
  const c = hex.replace('#','');
  const r = parseInt(c.substring(0,2),16), g = parseInt(c.substring(2,4),16), b = parseInt(c.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

/* ---------- show metric info popover ---------- */
function showMetricInfo(key){
  const meta = METRIC_INFO[key] || {name:key, desc:'Keine Beschreibung verfügbar', tip:''};
  alert(`${meta.name}\n\nBeschreibung: ${meta.desc}\n\nHinweis: ${meta.tip}`);
}

/* ---------- export functions ---------- */
function exportChartPNG(key){
  const inst = chartInstances[key];
  if(!inst) { alert('Kein Chart gefunden'); return; }
  const canvas = inst.canvas;
  canvas.toBlob(function(blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${key}.png`; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png', 1.0);
}
function exportChartJSON(key){
  const inst = chartInstances[key];
  if(!inst) { alert('Kein Chart gefunden'); return; }
  const data = inst.data;
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${key}.json`; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* ---------- Parse button: main flow ---------- */
parseBtn.addEventListener('click', ()=>{
  const raw = consoleEl.textContent || consoleEl.innerText || '';
  const metrics = parseMetricsFromText(raw);
  metricsByEpoch = metrics;
  if(metrics.length===0){
    // fallback: try to parse whole text as JSON array
    try{
      const arr = JSON.parse(raw);
      if(Array.isArray(arr)) metricsByEpoch = arr;
    }catch(e){}
  }

  allMetricKeys = detectAllMetricKeys(metricsByEpoch);
  // Ensure common keys are present (add placeholders)
  const required = ['epoch','train_loss','eval_loss','eval_accuracy','eval_f1','grad_norm','learning_rate','train_samples_per_second','train_steps_per_second','eval_samples_per_second','eval_steps_per_second'];
  for(const r of required) if(!allMetricKeys.includes(r)) allMetricKeys.push(r);

  buildCharts(metricsByEpoch);
  // also pretty-render console with colored highlights & progress-lines
  renderConsoleWithHighlights(raw);
});

/* ---------- Console rendering with highlights (progress bars, chips) ---------- */
function renderConsoleWithHighlights(raw){
  const lines = raw.split(/\r?\n/);
  const out = [];
  const tqdmRegex = /(\d{1,3})%.*?\|+/; // crude match for tqdm progress lines
  for(const line of lines){
    if(line.trim().length===0){ out.push('<div style="height:6px"></div>'); continue; }
    // detect epoch-style metric objects and show chips
    if(/\{[^}]*'epoch'\s*:\s*[\d.]+[^}]*\}|\{[^}]*"epoch"\s*:\s*[\d.]+[^}]*\}/.test(line)){
      // compress to one-line chip
      const compact = line.replace(/\s+/g,' ').slice(0,300);
      out.push(`<div class="chip" title="${escapeHtml(line)}">${escapeHtml(compact)}</div>`);
      continue;
    }
    // detect tqdm progress
    const p = line.match(tqdmRegex);
    if(p){
      const perc = Math.min(100, Math.max(0, Number(p[1])));
      const color = (perc>=90) ? COLOR_MAP.perf : (perc>=60 ? COLOR_MAP.scheduler : COLOR_MAP.loss);
      out.push(`<div class="progress-line"><div class="small">${perc}%</div><div class="progress-bar" title="${escapeHtml(line)}"><span class="progress-inner" style="width:${perc}%;background:${color};"></span></div><div style="margin-left:8px;color:var(--muted);font-size:12px">${escapeHtml(line.slice(0,120))}</div></div>`);
      continue;
    }
    // highlight keywords
    let l = escapeHtml(line)
      .replace(/\b(WARNING|WARNUNG|ERROR|UndefinedMetricWarning)\b/g, match => `<strong style="color:${COLOR_MAP.scheduler}">${match}</strong>`)
      .replace(/\b(GPU gefunden|Training erfolgreich abgeschlossen|Speichere das finale \*beste\* Modell)\b/g, match => `<strong style="color:${COLOR_MAP.perf}">${match}</strong>`)
      .replace(/\b(eval_loss|eval_accuracy|eval_f1|eval_precision|eval_recall|train_loss|epoch|grad_norm|learning_rate)\b/g, match => `<span style="color:${COLOR_MAP.default}">${match}</span>`);
    out.push(`<div style="white-space:pre-wrap;margin:2px 0">${l}</div>`);
  }
  consoleEl.innerHTML = out.join('\n');
}

/* ---------- small helpers ---------- */
function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

/* ---------- initial demo content (optional) ---------- */
(function initDemo(){
  const demoText = `"C:\\Users\\musicfiler\\...\\python.exe" "train_modell_multilingual.py"
2025-11-09 13:55:36.899318: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on.
WARNUNG: Paket 'stop-words' nicht gefunden. (pip install stop-words)
Fahre ohne deutsche Stopwörter fort.
Generating train split: 13178 examples [00:00, 77447.77 examples/s]
{'loss': 1.3446, 'grad_norm': 8.837105751037598, 'learning_rate': 6.233153638814016e-06, 'epoch': 1.0}
100%|██████████| 21/21 [00:01<00:00, 13.20it/s]
{'eval_loss': 0.7781473994255066, 'eval_accuracy': 0.661608497723824, 'eval_f1': 0.6036111075115989, 'eval_precision': 0.5747313219002144, 'eval_recall': 0.661608497723824, 'eval_runtime': 1.6039, 'eval_samples_per_second': 821.769, 'eval_steps_per_second': 13.093, 'epoch': 1.0}
{'loss': 0.5872, 'grad_norm': 32.88193893432617, 'learning_rate': 1.2483153638814016e-05, 'epoch': 2.0}
{'eval_loss': 0.4699881076812744, 'eval_accuracy': 0.8072837632776935, 'eval_f1': 0.8090864861095319, 'eval_precision': 0.8229205367280532, 'eval_recall': 0.8072837632776935, 'eval_runtime': 1.5852, 'eval_samples_per_second': 831.438, 'eval_steps_per_second': 13.247, 'epoch': 2.0}
... (kopiere kompletten Log hier) ...
{'train_runtime': 3883.2405, 'train_samples_per_second': 244.332, 'train_steps_per_second': 7.643, 'train_loss': 0.047262776140070066, 'epoch': 80.0}
`;
  consoleEl.textContent = demoText;
})();

</script>
</body>
</html>